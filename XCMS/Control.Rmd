---
title: "Falkor Control Script"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
library(tidyverse)
library(data.table)
library(pbapply)
library(xcms)
```

```{r specific_setup}
polarity <- "pos"

pretty_folder <- paste0("XCMS/", polarity, "_pretty/")
if(!dir.exists(pretty_folder)){dir.create(pretty_folder)}
intermediate_folder <- paste0("XCMS/", polarity, "_intermediate/")
if(!dir.exists(intermediate_folder)){dir.create(intermediate_folder)}

source("XCMS/scripts/functions.R")

ms_files <- "mzMLs/" %>%
  paste0(polarity) %>%
  list.files(pattern = ".mzML", full.names = TRUE) 

register(BPPARAM = SnowParam(tasks = length(ms_files), progressbar = TRUE))
```

## Setup and metadata things

The raw data is stored on the Synology drive in the Ingalls Lab as .raw file types. This data isn't super useful in its proprietary format, so it's easiest to convert those .raw files into .mzMLs with the "RunMsconvert.cmd" script in the project working directory. We write these files into the "mzMLs" folder in the working directory since they're also accessed by MSDIAL.

File contents (as of June 24, 2020):

```
msconvert Z:\1_QEdata\LTC\DATA\HILIC\190718_DepthProfiles_FK180310\*.raw --mzML --filter "peakPicking true 1-" --filter "polarity positive" -z -o mzMLs/pos/
msconvert Z:\1_QEdata\LTC\DATA\HILIC\HILIC_2017\170706_Gradients2.0_CruiseFilters_2\170706_Blk_Blk0p2_?.raw --mzML --filter "peakPicking true 1-" --filter "polarity positive" -z -o mzMLs/pos/
msconvert Z:\1_QEdata\LTC\DATA\HILIC\190718_DepthProfiles_FK180310\MSMS\*DDApos*.raw --mzML --filter "peakPicking true 1-" --filter "polarity positive" -z -o mzMLs/pos/MSMS/
msconvert Z:\1_QEdata\LTC\DATA\HILIC\190718_DepthProfiles_FK180310\*.raw --mzML --filter "peakPicking true 1-" --filter "polarity negative" -z -o mzMLs/neg/
msconvert Z:\1_QEdata\LTC\DATA\HILIC\HILIC_2017\170706_Gradients2.0_CruiseFilters_2\170706_Blk_Blk0p2_?.raw --mzML --filter "peakPicking true 1-" --filter "polarity negative" -z -o mzMLs/neg/
msconvert Z:\1_QEdata\LTC\DATA\HILIC\190718_DepthProfiles_FK180310\MSMS\*DDAneg*.raw --mzML --filter "peakPicking true 1-" --filter "polarity negative" -z -o mzMLs/neg/MSMS/
```

The code above calls msconvert, a command-line utility from Proteowizard, to convert the files into mzML format. It also splits them into positive and negative mode and separates out the MSMS information into a sub-folder. Per Katherine's recommendation, I'm using blanks from her Gradients 2.0 project rather than the ones Laura added for me.

We also need the metadata that goes with these files, containing information about treatment type, which are blanks, injection volume, etc. It's also good to pull down the standards file from the lab Github during this setup phase. The small script below does this by accessing the file names, the instrument-produced sample key, and the internet.

```{r metadatagrab}
# Metadata
file_paths <- ms_files %>%
  normalizePath() %>%
  `[`(!grepl("Fullneg|Fullpos|QC-KM1906", x = .))
metadframe <- data.frame(
  fileid=basename(file_paths),
  depth=regmatches(regexpr(pattern = "Std|Poo|Blk|DCM|25m", file_paths), x = file_paths),
  station=regmatches(regexpr(pattern = "Std|Poo|Blk|S62|S64|S77|S80", file_paths), 
                     x = file_paths)
)
station_spindirs <- c(Blk="Blk", S62="Cyclone", S64="Cyclone", 
                      S77="Anticyclone", S80="Anticyclone",
                      Poo="Poo", Std="Std")
metadframe$spindir=station_spindirs[metadframe$station]
station_times <- c(Blk="Blk", S62="Morning", S64="Afternoon", 
                   S77="Morning", S80="Afternoon",
                   Poo="Poo", Std="Std")
metadframe$time=station_times[metadframe$station]
write.csv(x = metadframe, row.names = FALSE, file = "XCMS/falkor_metadata.csv")
knitr::kable(head(metadframe))



# Sample key information
sample_key <- read.csv(paste0("Z:\\1_QEdata\\LTC\\DATA\\HILIC\\190718_Depth",
                              "Profiles_FK180310\\Sample.Key.HILIC.csv"),
                       skip = 1)
falkor_key <- sample_key %>%
  filter(grepl(pattern = "FK|Std", sample_key$Sample.Name)) %>%
  select(Sample.Name, Inj.vol) %>%
  add_row(Sample.Name="170706_Blk_Blk0p2_1", Inj.vol=1) %>%
  add_row(Sample.Name="170706_Blk_Blk0p2_2", Inj.vol=1) %>%
  add_row(Sample.Name="190715_Blk_KM1906U14-Blk_C", Inj.vol=1) %>%
  mutate(fileid=paste0(Sample.Name, ".mzML")) %>%
  select(-Sample.Name, inj_vol=Inj.vol) %>%
  arrange(fileid)
write.csv(falkor_key, file = "XCMS/falkor_sample_key.csv", row.names = FALSE)
knitr::kable(head(falkor_key))


# Standards information
raw_stans <- read.csv(paste0("https://raw.githubusercontent.com/",
                             "IngallsLabUW/Ingalls_Standards/master/",
                             "Ingalls_Lab_Standards_NEW.csv"))
falkor_stans <- raw_stans %>%
  filter(Column=="HILIC") %>%
  mutate(polarity=tolower(gsub(pattern = "HILIC", "", .$Fraction1))) %>%
  select(compound_type=Compound.Type, compound_name=Compound.Name, 
         formula=Emperical.Formula, rt=RT..min., mz=m.z, ionization_form,
         charge=z, kegg_id=C0, polarity)
write.csv(falkor_stans, file = "XCMS/falkor_stans.csv", row.names = FALSE)
knitr::kable(head(falkor_stans))
```

## Peakpicking

**Obviously** the most important step, you can't do anything else without first finding things to look at and talk about. The script below, when sourced, runs XCMS's centWave peakpicking. It also calculates an improved signal-to-noise and metric of Gaussian-ness that seems to sift through the noise more accurately than the default signal-to-noise ratio, which has known bugs (https://doi.org/10.1021/acs.analchem.7b01069). Finally, it performs retention time correction and peak correspondence (grouping peaks across files).

It takes in the metadataframe created above as well as the list of paths to the .mzML files and returns a (rather large) data frame full of peaks. 

```{r Peakpicking, eval=FALSE}

falkor_metadata <- read.csv("XCMS/falkor_metadata.csv")
ms_files <- falkor_metadata$fileid
qscore_threshold <- 50

source("XCMS/scripts/peakpicking.R")

saveRDS(xdata, file = paste0(intermediate_folder, "dirty_xdata.rds"))
saveRDS(xdata_filled, file = paste0(intermediate_folder, "current_xdata_filled.rds"))
print(xdata_filled)
write.csv(raw_peaks, file = paste0(intermediate_folder, "raw_peaks.csv"), row.names = FALSE)
knitr::kable(head(raw_peaks))
```

## De-isotoping and de-adducting

After peaks have been identified, many of them will be isotopes and adducts of other peaks. Removing these is important to minimize pseudoreplication issues and data artifacts. I didn't like any of the packages I tried to do this, so I wrote my own code to process this more robustly.

This script does two things. First, it identifies peaks that are likely isotopes or adducts of other peaks in the data set. It does this by assuming that every single peak is an isotope/adduct of another peak. If a peak is an adduct/isotope, there will be another peak that looks very similar but is separated by a very specific mass difference. For example, if we find a peak at 140.06875, we "guess" that it's an adduct or isotope and check all the places where the M+H would be found, depending on the isotope or adduct. If we suspect it of being a 13C isotope of another peak, we'd look for a peak at 140.06875-1.003355. If we suspect it of being a sodium isotope, we'd look for a peak at 140.06875-22.99787+1.007276. In this case, we would indeed find a signal at the M+H peak if we assume sodium, but no peak at the M+H if we assume a 13C isotope - allowing us to conclude tentatively that this is actually an adduct.

However, simply finding data at the expected mass isn't specific enough because we'll often stumble upon noise or a different peak in the general area. Thus, we check for peak similarity before assuming that there's real signal there. The general theory is that isotopes and adducts will be similar to the base peak in two ways. First, the individual x/y (rt/intensity) data points should match up almost exactly, as adducts and isotopes elute at the same time as the base peak. We can check this with a Pearson correlation - simply, how nicely do the two peaks correlate with each other? This method is quite sensitive to even small differences in retention time. Second, we can compare peak ratios across files. Here, we run a similar correlation but check x/y as base peak/isotope peak. This works because a compound will always create similarly stable adducts (some will love M+H, others M+Na) and will always have a fixed isotope abundance. Across the files, then, the correlation between these should be very strong (and is, in fact, usually stronger than the first method).

```{r deisoadduct, eval=FALSE}
xdata_filled <- readRDS(file = paste0(intermediate_folder, "current_xdata_filled.rds"))
raw_peaks <- read.csv(file = paste0(intermediate_folder, "raw_peaks.csv"))

# When removing peaks that are likely adducts...
# How similar do the median peak and median adduct need to be to assume adduct?
shape_remove_threshold <- 0.90
# How good does the peak area ~ adduct area correlation across files need to be to assume adduct?
area_remove_threshold <- 0.95

# When finding adducts and isotopes of a given peak...
# How similar do the median peak and median adduct need to be to assume adduct?
# Typically lower than above because priors are better
shape_find_threshold <- 0.8
# How good does the peak area ~ adduct area correlation across files need to be to assume adduct?
area_find_threshold <- 0.9

source("XCMS/scripts/deisoadduct.R")

# Write out data frame containing all adducts and isotopes
write.csv(addiso_peaks, file = paste0(pretty_folder, "addiso_peaks.csv"), row.names = FALSE)
knitr::kable(head(addiso_peaks))

# Write out data frame containing all "real" peaks
write.csv(real_peaks, file = paste0(intermediate_folder, "real_peaks.csv"), row.names = FALSE)
knitr::kable(head(real_peaks))

# Write out summary data frame containing deconvoluted MS1 information
write.csv(real_features, file = paste0(pretty_folder, "complete_features.csv"), row.names = FALSE)
knitr::kable(head(real_features))
```

## Finding B-MISs

```{r B-MIS, eval=FALSE}
addiso_peaks <- read.csv(paste0(pretty_folder, "addiso_peaks.csv")) %>%
  select(feature, mz, rt, into, file_name, M_area)
real_peaks <- read.csv(paste0(intermediate_folder, "real_peaks.csv")) %>%
  select(feature, mz, rt, into, file_name, M_area)
all_peaks <- rbind(addiso_peaks, real_peaks) %>%
  arrange("feature", "file_name")

falkor_stans <- read.csv("XCMS/falkor_stans.csv")
bionorm_values <- read.csv("XCMS/falkor_sample_key.csv")
cut.off <- 0.4 #Necessary improvement for "acceptable"
cut.off2 <- 0.1 #If RSD already below, skip B-MIS

source("XCMS/scripts/bmisscript.R")
```

